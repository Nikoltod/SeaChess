function computeColor(t, e, r) { return this.grid.charAt(9 * r + 3 * e + t) } function changeColor(t, e, r, a) { var o = this.grid.substr(0, 9 * r + 3 * e + t), n = this.grid.substr(9 * r + 3 * e + t + 1); this.grid = o + a + n } function otherPlayerColor() { return "R" == this.currentPlayer ? "B" : "R" } function changePlayer() { this.winner(), this.stalemate(), this.currentPlayer = this.otherPlayer() } function checkForWinner() { for (var t = $("#game-message"), e = 0; e < paths.length; e++) { var r = paths[e][0], a = paths[e][1], o = paths[e][2]; if (this.color(r[0], r[1], r[2]) == this.color(a[0], a[1], a[2]) && this.color(a[0], a[1], a[2]) == this.color(o[0], o[1], o[2]) && this.color(o[0], o[1], o[2]) == this.currentPlayer) return this.gameOver = !0, $("#game-message-container").removeAttr("style"), "R" == this.currentPlayer ? (t.text("Red won the game!"), console.log("whaat")) : t.text("Blue won the game!"), !0 } return !1 } function checkForStalemante() { var t = this.grid.indexOf("G") < 0; return t && (this.gameOver = !0, $("#game-message-container").removeAttr("style"), $("#game-message").text("The game ended in a draw.")), t } function board(t, e, r) { this.grid = t, this.currentPlayer = "R", this.player1 = e, this.player2 = r, this.gameOver = !1, this.otherPlayer = otherPlayerColor, this.endTurn = changePlayer, this.color = computeColor, this.setColor = changeColor, this.winner = checkForWinner, this.stalemate = checkForStalemante } function drawCubeBottom(t, e, r) { var a = document.getElementById("output"), o = a.getContext("2d"), n = o.createLinearGradient(0, 0, 0, 360); n.addColorStop(0, "#000000"), n.addColorStop(1, "grey"), o.shadowBlur = 10, o.shadowColor = "black", o.fillStyle = n, o.beginPath(), o.moveTo(t, e), o.lineTo(t + r / 2, e - r / 2), o.lineTo(t + r / 2 + r, e - r / 2), o.lineTo(t + r, e), o.lineTo(t, e), o.closePath(), o.fill(), o.shadowBlur = 0 } function drawOuterCube(t, e, r) { var a = document.getElementById("output"), o = a.getContext("2d"); o.beginPath(), o.moveTo(t - r / 2, e + r / 2), o.lineTo(t + r / 2, e + r / 2), o.lineTo(t + r, e), o.lineTo(t, e), o.lineTo(t - r / 2, e + r / 2), o.closePath(), o.fill() } function drawInnerCube(t, e, r, a, o, n, i, s, l) { var h = document.getElementById("output"), d = h.getContext("2d"), c = d.createLinearGradient(t, e - r, t, e); c.addColorStop(0, a), c.addColorStop(1, o), d.fillStyle = c, d.fillRect(t - r / 2, e - r / 2, r, r); var u = d.createLinearGradient(t, e - r, t + 1.5 * r, e - 1.5 * r); u.addColorStop(0, l), u.addColorStop(1, s), d.fillStyle = u, d.beginPath(), d.moveTo(t - r / 2, e - r / 2), d.lineTo(t, e - r), d.lineTo(t + r, e - r), d.lineTo(t + r / 2, e - r / 2), d.lineTo(t - r / 2, e - r / 2), d.closePath(), d.fill(); var p = d.createLinearGradient(t + r, e - 1.5 * r, t + r, e); p.addColorStop(0, n), p.addColorStop(1, i), d.fillStyle = p, d.beginPath(), d.moveTo(t + r / 2, e - r / 2), d.lineTo(t + r, e - r), d.lineTo(t + r, e), d.lineTo(t + r / 2, e + r / 2), d.lineTo(t + r / 2, e - r / 2), d.closePath(), d.fill() } function draw(t, e, r, a) { void 0 === e && (e = -1, r = -1, a = -1); var o = document.getElementById("output"); o.width = o.width; var n = o.getContext("2d"), i = n.createLinearGradient(0, 0, 0, 360); i.addColorStop(0, "#888888"), i.addColorStop(1, "#B0B0B0"), n.shadowBlur = 10, n.shadowColor = "black", n.fillStyle = i, drawOuterCube(160, 320, 240), n.shadowBlur = 0; var s = "#FB0000", l = "#BB0000", h = "#FF4535", d = "#D41201", c = "#FF5445", u = "#FB0000", p = "#0000D4", m = "#000099", g = "#2C2CD4", f = "#0000BA", G = "#3E3ED6", v = "#0000D4", C = 80, P = 6, w = 160, b = 320; for (x = 0; x <= 2; x++) for (y = 0; y <= 2; y++) for (z = 0; z <= 2; z++) { var B = t.color(x, y, z), T = w + x * C - y * (C / 2) - C / 2, S = b + y * (C / 2) - z * C + C / 2, F = w + P / 2 + x * C - y * (C / 2), I = b - P + y * (C / 2) - z * C; x == e && y == r && 0 == z && drawCubeBottom(T, S, C), "R" == B && drawInnerCube(F, I, C - 2 * P, s, l, h, d, c, u), "B" == B && drawInnerCube(F, I, C - 2 * P, p, m, g, f, G, v) } $(".tile").each(function () { var e = parseInt($(this).attr("boardx")), r = parseInt($(this).attr("boardy")), a = parseInt($(this).attr("boardz")); $(this).removeClass("R"), $(this).removeClass("B"), "G" != t.color(e, r, a) && $(this).addClass(t.color(e, r, a)) }) } function pathStatus(t, e, r, a) { this.friendly = 0, this.neutral = 0, this.enemy = 0, t.color(e[0], e[1], e[2]) == t.currentPlayer && this.friendly++, "G" == t.color(e[0], e[1], e[2]) && this.neutral++, t.color(e[0], e[1], e[2]) == t.otherPlayer() && this.enemy++, t.color(r[0], r[1], r[2]) == t.currentPlayer && this.friendly++, "G" == t.color(r[0], r[1], r[2]) && this.neutral++, t.color(r[0], r[1], r[2]) == t.otherPlayer() && this.enemy++, t.color(a[0], a[1], a[2]) == t.currentPlayer && this.friendly++, "G" == t.color(a[0], a[1], a[2]) && this.neutral++, t.color(a[0], a[1], a[2]) == t.otherPlayer() && this.enemy++ } function divide(t, e) { var r = t % e, a = (t - r) / e; return a } function move(t, e, r) { this.x = t, this.y = e, this.z = r } function doComputerMove(t) { var e = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; updatePrioritiesForWinning(t, e) || updatePrioritiesForBlockingOpponentFromWinning(t, e) || updatePrioritesForWinningAndBlockingPaths(t, e); for (var r = -1, a = 0; a < e.length; a++) e[a] > r && (r = e[a]); for (var o = [], a = 0; a < e.length; a++) e[a] == r && o.push(a); var n = Math.floor(Math.random() * o.length), i = o[n], s = divide(i, 9), l = divide(i - 9 * s, 3), h = i % 3; return t.setColor(h, l, s, t.currentPlayer), $.ajax({ url: "/Game/GetGameBoard/" + t.grid, success: function (e) { t.grid = e } }), new move(h, l, s) } function updatePrioritiesForWinning(t, e) { for (var r = 0; r < paths.length; r++) { var a = paths[r][0], o = paths[r][1], n = paths[r][2], i = new pathStatus(t, a, o, n); if (2 == i.friendly && 1 == i.neutral) return "G" == t.color(a[0], a[1], a[2]) && e[a[0] + 3 * a[1] + 9 * a[2]]++, "G" == t.color(o[0], o[1], o[2]) && e[o[0] + 3 * o[1] + 9 * o[2]]++, "G" == t.color(n[0], n[1], n[2]) && e[n[0] + 3 * n[1] + 9 * n[2]]++, !0 } return !1 } function updatePrioritiesForBlockingOpponentFromWinning(t, e) { for (var r = 0; r < paths.length; r++) { var a = paths[r][0], o = paths[r][1], n = paths[r][2], i = new pathStatus(t, a, o, n); if (2 == i.enemy && 1 == i.neutral) return "G" == t.color(a[0], a[1], a[2]) && e[a[0] + 3 * a[1] + 9 * a[2]]++, "G" == t.color(o[0], o[1], o[2]) && e[o[0] + 3 * o[1] + 9 * o[2]]++, "G" == t.color(n[0], n[1], n[2]) && e[n[0] + 3 * n[1] + 9 * n[2]]++, !0 } return !1 } function updatePrioritesForWinningAndBlockingPaths(t, e) { for (var r = 0; r < paths.length; r++) { var a = paths[r][0], o = paths[r][1], n = paths[r][2], i = new pathStatus(t, a, o, n); 2 == i.neutral && ("G" == t.color(a[0], a[1], a[2]) && e[a[0] + 3 * a[1] + 9 * a[2]]++, "G" == t.color(o[0], o[1], o[2]) && e[o[0] + 3 * o[1] + 9 * o[2]]++, "G" == t.color(n[0], n[1], n[2]) && e[n[0] + 3 * n[1] + 9 * n[2]]++) } } function pcVsPc(t) { if (!t.gameOver) { var e = doComputerMove(t), r = "div[boardx='" + e.x + "'][boardy='" + e.y + "'][boardz='" + e.z + "']"; $(r).addClass(t.currentPlayer), draw(t) } t.gameOver || (t.endTurn(), setTimeout(function () { pcVsPc(t) }, 2e3)) } function startNewGame() { $("#game-message-container").attr("style", "display:none"); var t = $("#player1").children("div").html().toLowerCase(), e = $("#player2").children("div").html().toLowerCase(), r = new board("GGGGGGGGGGGGGGGGGGGGGGGGGGG", t, e); if ($(".tile").removeClass("R"), $(".tile").removeClass("B"), draw(r), "computer" == r.player1 && "computer" == r.player2) setTimeout(function () { pcVsPc(r) }, 2e3); else if ("computer" == r.player1) { var a = doComputerMove(r), o = "div[boardx='" + a.x + "'][boardy='" + a.y + "'][boardz='" + a.z + "']"; $(o).addClass(r.currentPlayer), draw(r), r.endTurn() } return r } var paths = []; paths[0] = [[0, 0, 0], [1, 0, 0], [2, 0, 0]], paths[1] = [[0, 1, 0], [1, 1, 0], [2, 1, 0]], paths[2] = [[0, 2, 0], [1, 2, 0], [2, 2, 0]], paths[3] = [[0, 0, 0], [0, 1, 0], [0, 2, 0]], paths[4] = [[1, 0, 0], [1, 1, 0], [1, 2, 0]], paths[5] = [[2, 0, 0], [2, 1, 0], [2, 2, 0]], paths[6] = [[0, 0, 0], [1, 1, 0], [2, 2, 0]], paths[7] = [[2, 0, 0], [1, 1, 0], [0, 2, 0]], paths[8] = [[0, 0, 1], [1, 0, 1], [2, 0, 1]], paths[9] = [[0, 1, 1], [1, 1, 1], [2, 1, 1]], paths[10] = [[0, 2, 1], [1, 2, 1], [2, 2, 1]], paths[11] = [[0, 0, 1], [0, 1, 1], [0, 2, 1]], paths[12] = [[1, 0, 1], [1, 1, 1], [1, 2, 1]], paths[13] = [[2, 0, 1], [2, 1, 1], [2, 2, 1]], paths[14] = [[0, 0, 1], [1, 1, 1], [2, 2, 1]], paths[15] = [[2, 0, 1], [1, 1, 1], [0, 2, 1]], paths[16] = [[0, 0, 2], [1, 0, 2], [2, 0, 2]], paths[17] = [[0, 1, 2], [1, 1, 2], [2, 1, 2]], paths[18] = [[0, 2, 2], [1, 2, 2], [2, 2, 2]], paths[19] = [[0, 0, 2], [0, 1, 2], [0, 2, 2]], paths[20] = [[1, 0, 2], [1, 1, 2], [1, 2, 2]], paths[21] = [[2, 0, 2], [2, 1, 2], [2, 2, 2]], paths[22] = [[0, 0, 2], [1, 1, 2], [2, 2, 2]], paths[23] = [[2, 0, 2], [1, 1, 2], [0, 2, 2]], paths[24] = [[0, 0, 0], [0, 0, 1], [0, 0, 2]], paths[25] = [[1, 0, 0], [1, 0, 1], [1, 0, 2]], paths[26] = [[2, 0, 0], [2, 0, 1], [2, 0, 2]], paths[27] = [[0, 1, 0], [0, 1, 1], [0, 1, 2]], paths[28] = [[1, 1, 0], [1, 1, 1], [1, 1, 2]], paths[29] = [[2, 1, 0], [2, 1, 1], [2, 1, 2]], paths[30] = [[0, 2, 0], [0, 2, 1], [0, 2, 2]], paths[31] = [[1, 2, 0], [1, 2, 1], [1, 2, 2]], paths[32] = [[2, 2, 0], [2, 2, 1], [2, 2, 2]], paths[33] = [[0, 0, 0], [0, 1, 1], [0, 2, 2]], paths[34] = [[1, 0, 0], [1, 1, 1], [1, 2, 2]], paths[35] = [[2, 0, 0], [2, 1, 1], [2, 2, 2]], paths[36] = [[0, 2, 0], [0, 1, 1], [0, 0, 2]], paths[37] = [[1, 2, 0], [1, 1, 1], [1, 0, 2]], paths[38] = [[2, 2, 0], [2, 1, 1], [2, 0, 2]], paths[39] = [[0, 0, 0], [1, 0, 1], [2, 0, 2]], paths[40] = [[0, 1, 0], [1, 1, 1], [2, 1, 2]], paths[41] = [[0, 2, 0], [1, 2, 1], [2, 2, 2]], paths[42] = [[2, 0, 0], [1, 0, 1], [0, 0, 2]], paths[43] = [[2, 1, 0], [1, 1, 1], [0, 1, 2]], paths[44] = [[2, 2, 0], [1, 2, 1], [0, 2, 2]], paths[45] = [[0, 0, 0], [1, 1, 1], [2, 2, 2]], paths[46] = [[0, 2, 0], [1, 1, 1], [2, 0, 2]], paths[47] = [[2, 0, 0], [1, 1, 1], [0, 2, 2]], paths[47] = [[2, 2, 0], [1, 1, 1], [0, 0, 2]], jQuery(function () { var t = startNewGame(); $.ajax({ url: "/Game/GetGameBoard/", success: function (e) { t.grid = e, draw(t) } }), $(".tile").hover(function () { if (!t.gameOver) { var e = parseInt($(this).attr("boardx")), r = parseInt($(this).attr("boardy")), a = parseInt($(this).attr("boardz")), o = new board(t.grid, t.player1, t.player2); "G" == t.color(e, r, a) && o.setColor(e, r, a, t.currentPlayer), draw(o, e, r, a) } }, function () { t.gameOver || draw(t) }), $(".tile").click(function () { if (!t.gameOver) { var e = parseInt($(this).attr("boardx")), r = parseInt($(this).attr("boardy")), a = parseInt($(this).attr("boardz")); "G" == t.color(e, r, a) && ($(this).addClass(t.currentPlayer), t.setColor(e, r, a, t.currentPlayer), $.ajax({ url: "/Game/GetGameBoard/" + t.grid, success: function (e) { if (t.grid = e, draw(t), t.winner() || t.stalemate()); else if (t.endTurn(), "R" == t.currentPlayer && "computer" == t.player1 || "B" == t.currentPlayer && "computer" == t.player2) { var r = doComputerMove(t), a = "div[boardx='" + r.x + "'][boardy='" + r.y + "'][boardz='" + r.z + "']"; $(a).addClass(t.currentPlayer), t.endTurn(), draw(t) } } })) } }), $("li.option").click(function () { $(this).parent().siblings("div").html($(this).text()), t.gameOver = !0, t = startNewGame(), $.ajax({ url: "/Game/EndGame/", success: function () { $.ajax({ url: "/Game/GetGameBoard/", success: function (e) { t.grid = e } }) } }) }), $("#start-new-game").click(function () { return t = startNewGame(), $.ajax({ url: "/Game/EndGame/", success: function () { $.ajax({ url: "/Game/GetGameBoard/", success: function (e) { t.grid = e } }) } }), !1 }) }); 